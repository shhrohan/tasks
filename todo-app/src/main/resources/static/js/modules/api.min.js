const TASKS_URL="/api/tasks",SWIMLANES_URL="/api/swimlanes",USER_URL="/api/user",SSE_URL="/api/sse/stream";"undefined"!=typeof axios?(axios.interceptors.request.use(e=>(console.log(`[API] >>> REQUEST: ${e.method.toUpperCase()} ${e.url}`),e.data&&console.log("[API] >>> Payload:",e.data),e.params&&console.log("[API] >>> Params:",e.params),e)),axios.interceptors.response.use(e=>(console.log(`[API] <<< RESPONSE: ${e.config.method.toUpperCase()} ${e.config.url} - Status: ${e.status}`),console.log("[API] <<< Data:",e.data),e),e=>(console.error("[API] <<< ERROR:",{url:e.config?.url,method:e.config?.method,status:e.response?.status,message:e.message,data:e.response?.data}),!e.response||401!==e.response.status&&403!==e.response.status||(console.warn("[API] Session expired or unauthorized. Redirecting to login..."),window.location.href="/login"),Promise.reject(e)))):console.error("[API] FATAL: Axios is not loaded! API calls will fail.");export const Api={async fetchTasks(){console.log("[API] fetchTasks() - Fetching all tasks");const e=await axios.get(TASKS_URL);return console.log(`[API] fetchTasks() - Returned ${e.data.length} tasks`),e.data},async fetchTasksByLane(e){console.log(`[API] fetchTasksByLane() - Params: { swimLaneId: ${e} }`);const t=await axios.get(`${TASKS_URL}/swimlane/${e}`);return console.log(`[API] fetchTasksByLane(${e}) - Returned ${t.data.length} tasks`),t.data},async createTask(e){console.log("[API] createTask() - Params:",e);const t=await axios.post(TASKS_URL,e);return console.log("[API] createTask() - Created task:",t.data),t.data},async updateTask(e,t){console.log(`[API] updateTask() - Params: { id: ${e}, data:`,t,"}");const n=await axios.put(`${TASKS_URL}/${e}`,t);return console.log("[API] updateTask() - Updated task:",n.data),n.data},async moveTask(e,t,n,o){console.log("[API] moveTask() - Params:",{id:e,status:t,swimLaneId:n,position:o});let s=`${TASKS_URL}/${e}/move?status=${t}&swimLaneId=${n}`;null!=o&&(s+=`&position=${o}`),console.log(`[API] moveTask() - Full URL: ${s}`);const a=await axios.patch(s);return console.log("[API] moveTask() - Response:",a.data),a.data},async deleteTask(e){console.log(`[API] deleteTask() - Params: { id: ${e} }`),await axios.delete(`${TASKS_URL}/${e}`),console.log(`[API] deleteTask(${e}) - Deleted successfully`)},async addComment(e,t){console.log("[API] addComment() - Params:",{taskId:e,text:t});const n=await axios.post(`${TASKS_URL}/${e}/comments`,t,{headers:{"Content-Type":"text/plain"}});return console.log("[API] addComment() - Response:",n.data),n.data},async updateComment(e,t,n){console.log("[API] updateComment() - Params:",{taskId:e,commentId:t,text:n});const o=await axios.put(`${TASKS_URL}/${e}/comments/${t}`,n,{headers:{"Content-Type":"text/plain"}});return console.log("[API] updateComment() - Response:",o.data),o.data},async deleteComment(e,t){console.log("[API] deleteComment() - Params:",{taskId:e,commentId:t}),await axios.delete(`${TASKS_URL}/${e}/comments/${t}`),console.log("[API] deleteComment() - Deleted successfully")},async fetchAllSwimLanes(){console.log("[API] fetchAllSwimLanes() - Fetching all swimlanes");const e=await axios.get(SWIMLANES_URL);return console.log(`[API] fetchAllSwimLanes() - Returned ${e.data.length} lanes`),e.data},async fetchSwimLanes(){console.log("[API] fetchSwimLanes() - Fetching active swimlanes");const e=await axios.get(`${SWIMLANES_URL}/active`);return console.log(`[API] fetchSwimLanes() - Returned ${e.data.length} lanes`),e.data},async fetchCompletedSwimLanes(){console.log("[API] fetchCompletedSwimLanes() - Fetching completed swimlanes");const e=await axios.get(`${SWIMLANES_URL}/completed`);return console.log(`[API] fetchCompletedSwimLanes() - Returned ${e.data.length} lanes`),e.data},async createSwimLane(e){console.log(`[API] createSwimLane() - Params: { name: "${e}" }`);const t=await axios.post(SWIMLANES_URL,{name:e});return console.log("[API] createSwimLane() - Created lane:",t.data),t.data},async reorderSwimlanes(e){console.log("[API] reorderSwimlanes() - Params:",{orderedIds:e}),await axios.patch(`${SWIMLANES_URL}/reorder`,e),console.log("[API] reorderSwimlanes() - Reorder successful")},async completeSwimLane(e){console.log(`[API] completeSwimLane() - Params: { id: ${e} }`);const t=await axios.patch(`${SWIMLANES_URL}/${e}/complete`);return console.log("[API] completeSwimLane() - Response:",t.data),t.data},async uncompleteSwimLane(e){console.log(`[API] uncompleteSwimLane() - Params: { id: ${e} }`);const t=await axios.patch(`${SWIMLANES_URL}/${e}/uncomplete`);return console.log("[API] uncompleteSwimLane() - Response:",t.data),t.data},async deleteSwimLane(e){console.log(`[API] deleteSwimLane() - Params: { id: ${e} }`),await axios.delete(`${SWIMLANES_URL}/${e}`),console.log(`[API] deleteSwimLane(${e}) - Deleted successfully`)},async updateUser(e){console.log(`[API] updateUser() - Params: { name: "${e}" }`);const t=await axios.put(USER_URL,e,{headers:{"Content-Type":"text/plain"}});return console.log("[API] updateUser() - Response:",t.data),t.data},currentEventSource:null,beforeUnloadRegistered:!1,isConnected:!0,reconnectAttempts:0,maxReconnectAttempts:10,lastHeartbeat:Date.now(),monitorInterval:null,showConnectionLostOverlay(){let e=document.getElementById("connection-lost-overlay");e||(e=document.createElement("div"),e.id="connection-lost-overlay",e.classList.add("connection-navigation-overlay"),e.innerHTML='\n                <div class="connection-lost-content animate__animated animate__fadeInDown">\n                    <div class="connection-icon-wrapper mb-3">\n                        <i class="fa-solid fa-wifi-slash fa-3x"></i>\n                        <div class="connection-pulse"></div>\n                    </div>\n                    <h4>Connection Lost</h4>\n                    <p class="text-secondary mb-3">The server is restarting or your connection was interrupted. Attempting to reconnect...</p>\n                    <div class="d-flex align-items-center justify-content-center gap-2 mb-2">\n                        <div class="spinner-border spinner-border-sm text-primary" role="status"></div>\n                        <span class="small" id="reconnect-status">Initializing...</span>\n                    </div>\n                    <div class="reconnect-progress-container mt-3">\n                        <div class="reconnect-progress-bar" id="reconnect-progress"></div>\n                    </div>\n                </div>\n            ',document.body.appendChild(e)),e.style.display="flex",console.log("[SSE] Connection lost overlay shown")},hideConnectionLostOverlay(){const e=document.getElementById("connection-lost-overlay");e&&(e.style.display="none"),console.log("[SSE] Connection restored, overlay hidden")},updateReconnectStatus(e){const t=document.getElementById("reconnect-status");if(t&&(t.textContent=e),e.includes("Attempt")){const t=e.match(/Attempt (\d+)\/(\d+)/);if(t){const e=parseInt(t[1]),n=parseInt(t[2]),o=document.getElementById("reconnect-progress");o&&(o.style.width=e/n*100+"%")}}},startConnectionMonitor(){this.monitorInterval&&clearInterval(this.monitorInterval),console.log("[SSE] Starting connection monitor (checking every 5s)..."),this.monitorInterval=setInterval(()=>{const e=Date.now()-this.lastHeartbeat,t=e>25e3,n=!navigator.onLine;this.isConnected&&(t||n)?(console.warn(`[SSE] Connection monitor detected failure! Stale: ${t} (${Math.round(e/1e3)}s), Offline: ${n}`),this.isConnected=!1,this.showConnectionLostOverlay(),this.updateReconnectStatus(n?"You are offline":"Waiting for server heartbeat..."),t&&this.currentEventSource&&(this.currentEventSource.close(),this.currentEventSource=null)):t||!n||this.isConnected||this.updateReconnectStatus("Re-establishing connection...")},5e3)},initSSE(e,t,n){console.log("[SSE] Initializing connection to",SSE_URL),this.currentEventSource&&(console.log("[SSE] Closing previous connection"),this.currentEventSource.close(),this.currentEventSource=null);const o=new EventSource(SSE_URL);return this.currentEventSource=o,this.beforeUnloadRegistered||(window.addEventListener("beforeunload",()=>{this.currentEventSource&&(console.log("[SSE] Page unloading, closing connection"),this.currentEventSource.close(),this.currentEventSource=null)}),this.beforeUnloadRegistered=!0,console.log("[SSE] Registered beforeunload cleanup handler")),o.onopen=()=>{console.log("[SSE] Connection established"),this.isConnected=!0,this.reconnectAttempts=0,this.lastHeartbeat=Date.now(),this.hideConnectionLostOverlay()},o.addEventListener("task-updated",t=>{const n=JSON.parse(t.data);console.log("[SSE] Event: task-updated",n),e(n)}),o.addEventListener("task-deleted",e=>{const n=JSON.parse(e.data);console.log("[SSE] Event: task-deleted",{taskId:n}),t(n)}),o.addEventListener("lane-updated",e=>{const t=JSON.parse(e.data);console.log("[SSE] Event: lane-updated",t),n(t)}),o.addEventListener("heartbeat",e=>{console.log("[SSE] Heartbeat received from server"),this.lastHeartbeat=Date.now(),this.isConnected||(console.log("[SSE] Connection restored via heartbeat"),this.isConnected=!0,this.reconnectAttempts=0,this.hideConnectionLostOverlay())}),o.onerror=o=>{if(console.error("[SSE] Connection error event fired",o),this.isConnected=!1,this.reconnectAttempts++,this.currentEventSource&&(this.currentEventSource.close(),this.currentEventSource=null),this.showConnectionLostOverlay(),this.reconnectAttempts<=this.maxReconnectAttempts){const o=Math.min(2e3*this.reconnectAttempts,1e4);this.updateReconnectStatus(`Attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}... (${o/1e3}s)`),console.log(`[SSE] Reconnecting in ${o}ms (attempt ${this.reconnectAttempts})`),setTimeout(()=>this.initSSE(e,t,n),o)}else this.updateReconnectStatus("Connection failed. Please refresh the page."),console.error("[SSE] Max reconnect attempts reached")},o}};