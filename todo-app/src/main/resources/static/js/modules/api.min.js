const TASKS_URL="/api/tasks",SWIMLANES_URL="/api/swimlanes",USER_URL="/api/user",SSE_URL="/api/sse/stream";"undefined"!=typeof axios?(axios.interceptors.request.use(e=>(console.log(`[API] >>> REQUEST: ${e.method.toUpperCase()} ${e.url}`),e.data&&console.log("[API] >>> Payload:",e.data),e.params&&console.log("[API] >>> Params:",e.params),e)),axios.interceptors.response.use(e=>(console.log(`[API] <<< RESPONSE: ${e.config.method.toUpperCase()} ${e.config.url} - Status: ${e.status}`),console.log("[API] <<< Data:",e.data),e),e=>(console.error("[API] <<< ERROR:",{url:e.config?.url,method:e.config?.method,status:e.response?.status,message:e.message,data:e.response?.data}),Promise.reject(e)))):console.error("[API] FATAL: Axios is not loaded! API calls will fail.");export const Api={async fetchTasks(){console.log("[API] fetchTasks() - Fetching all tasks");const e=await axios.get(TASKS_URL);return console.log(`[API] fetchTasks() - Returned ${e.data.length} tasks`),e.data},async fetchTasksByLane(e){console.log(`[API] fetchTasksByLane() - Params: { swimLaneId: ${e} }`);const t=await axios.get(`${TASKS_URL}/swimlane/${e}`);return console.log(`[API] fetchTasksByLane(${e}) - Returned ${t.data.length} tasks`),t.data},async createTask(e){console.log("[API] createTask() - Params:",e);const t=await axios.post(TASKS_URL,e);return console.log("[API] createTask() - Created task:",t.data),t.data},async updateTask(e,t){console.log(`[API] updateTask() - Params: { id: ${e}, data:`,t,"}");const n=await axios.put(`${TASKS_URL}/${e}`,t);return console.log("[API] updateTask() - Updated task:",n.data),n.data},async moveTask(e,t,n,o){console.log("[API] moveTask() - Params:",{id:e,status:t,swimLaneId:n,position:o});let a=`${TASKS_URL}/${e}/move?status=${t}&swimLaneId=${n}`;null!=o&&(a+=`&position=${o}`),console.log(`[API] moveTask() - Full URL: ${a}`);const s=await axios.patch(a);return console.log("[API] moveTask() - Response:",s.data),s.data},async deleteTask(e){console.log(`[API] deleteTask() - Params: { id: ${e} }`),await axios.delete(`${TASKS_URL}/${e}`),console.log(`[API] deleteTask(${e}) - Deleted successfully`)},async addComment(e,t){console.log("[API] addComment() - Params:",{taskId:e,text:t});const n=await axios.post(`${TASKS_URL}/${e}/comments`,t,{headers:{"Content-Type":"text/plain"}});return console.log("[API] addComment() - Response:",n.data),n.data},async updateComment(e,t,n){console.log("[API] updateComment() - Params:",{taskId:e,commentId:t,text:n});const o=await axios.put(`${TASKS_URL}/${e}/comments/${t}`,n,{headers:{"Content-Type":"text/plain"}});return console.log("[API] updateComment() - Response:",o.data),o.data},async deleteComment(e,t){console.log("[API] deleteComment() - Params:",{taskId:e,commentId:t}),await axios.delete(`${TASKS_URL}/${e}/comments/${t}`),console.log("[API] deleteComment() - Deleted successfully")},async fetchAllSwimLanes(){console.log("[API] fetchAllSwimLanes() - Fetching all swimlanes");const e=await axios.get(SWIMLANES_URL);return console.log(`[API] fetchAllSwimLanes() - Returned ${e.data.length} lanes`),e.data},async fetchSwimLanes(){console.log("[API] fetchSwimLanes() - Fetching active swimlanes");const e=await axios.get(`${SWIMLANES_URL}/active`);return console.log(`[API] fetchSwimLanes() - Returned ${e.data.length} lanes`),e.data},async fetchCompletedSwimLanes(){console.log("[API] fetchCompletedSwimLanes() - Fetching completed swimlanes");const e=await axios.get(`${SWIMLANES_URL}/completed`);return console.log(`[API] fetchCompletedSwimLanes() - Returned ${e.data.length} lanes`),e.data},async createSwimLane(e){console.log(`[API] createSwimLane() - Params: { name: "${e}" }`);const t=await axios.post(SWIMLANES_URL,{name:e});return console.log("[API] createSwimLane() - Created lane:",t.data),t.data},async reorderSwimlanes(e){console.log("[API] reorderSwimlanes() - Params:",{orderedIds:e}),await axios.patch(`${SWIMLANES_URL}/reorder`,e),console.log("[API] reorderSwimlanes() - Reorder successful")},async completeSwimLane(e){console.log(`[API] completeSwimLane() - Params: { id: ${e} }`);const t=await axios.patch(`${SWIMLANES_URL}/${e}/complete`);return console.log("[API] completeSwimLane() - Response:",t.data),t.data},async uncompleteSwimLane(e){console.log(`[API] uncompleteSwimLane() - Params: { id: ${e} }`);const t=await axios.patch(`${SWIMLANES_URL}/${e}/uncomplete`);return console.log("[API] uncompleteSwimLane() - Response:",t.data),t.data},async deleteSwimLane(e){console.log(`[API] deleteSwimLane() - Params: { id: ${e} }`),await axios.delete(`${SWIMLANES_URL}/${e}`),console.log(`[API] deleteSwimLane(${e}) - Deleted successfully`)},async updateUser(e){console.log(`[API] updateUser() - Params: { name: "${e}" }`);const t=await axios.put(USER_URL,e,{headers:{"Content-Type":"text/plain"}});return console.log("[API] updateUser() - Response:",t.data),t.data},isConnected:!0,reconnectAttempts:0,maxReconnectAttempts:10,showConnectionLostOverlay(){let e=document.getElementById("connection-lost-overlay");e||(e=document.createElement("div"),e.id="connection-lost-overlay",e.innerHTML='\n                <div class="connection-lost-content">\n                    <i class="fa-solid fa-wifi-slash fa-3x mb-3"></i>\n                    <h4>Connection Lost</h4>\n                    <p class="text-secondary mb-2">Attempting to reconnect...</p>\n                    <div class="spinner-border spinner-border-sm text-primary" role="status">\n                        <span class="visually-hidden">Reconnecting...</span>\n                    </div>\n                    <p class="text-muted small mt-2" id="reconnect-status"></p>\n                </div>\n            ',e.style.cssText="\n                position: fixed;\n                top: 0;\n                left: 0;\n                width: 100%;\n                height: 100%;\n                background: rgba(0,0,0,0.85);\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                z-index: 99999;\n                color: white;\n                text-align: center;\n            ",document.body.appendChild(e)),e.style.display="flex",console.log("[SSE] Connection lost overlay shown")},hideConnectionLostOverlay(){const e=document.getElementById("connection-lost-overlay");e&&(e.style.display="none"),console.log("[SSE] Connection restored, overlay hidden")},updateReconnectStatus(e){const t=document.getElementById("reconnect-status");t&&(t.textContent=e)},initSSE(e,t,n){console.log("[SSE] Initializing connection to",SSE_URL);const o=new EventSource(SSE_URL);return o.onopen=()=>{console.log("[SSE] Connection established"),this.isConnected=!0,this.reconnectAttempts=0,this.hideConnectionLostOverlay()},o.addEventListener("task-updated",t=>{const n=JSON.parse(t.data);console.log("[SSE] Event: task-updated",n),e(n)}),o.addEventListener("task-deleted",e=>{const n=JSON.parse(e.data);console.log("[SSE] Event: task-deleted",{taskId:n}),t(n)}),o.addEventListener("lane-updated",e=>{const t=JSON.parse(e.data);console.log("[SSE] Event: lane-updated",t),n(t)}),o.onerror=a=>{if(console.error("[SSE] Connection error",a),this.isConnected=!1,this.reconnectAttempts++,o.close(),this.showConnectionLostOverlay(),this.reconnectAttempts<=this.maxReconnectAttempts){const o=Math.min(5e3*this.reconnectAttempts,3e4);this.updateReconnectStatus(`Attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}... (${o/1e3}s)`),console.log(`[SSE] Reconnecting in ${o}ms (attempt ${this.reconnectAttempts})`),setTimeout(()=>this.initSSE(e,t,n),o)}else this.updateReconnectStatus("Connection failed. Please refresh the page."),console.error("[SSE] Max reconnect attempts reached")},o}};