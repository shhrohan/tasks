import{Api}from"./api.js";export const Store={lanes:[],tasks:[],loading:!1,showSaved:!1,showErrorToast:!1,errorMessage:"",saveTimeout:null,errorTimeout:null,modal:{open:!1,title:"",message:"",type:"info",confirmText:"Confirm",action:null,payload:null},inputModal:{open:!1,title:"",value:"",status:"TODO",tags:[],tagInput:"",laneName:"",mode:"",payload:null},columns:["TODO","IN_PROGRESS","DONE","BLOCKED","DEFERRED"],async init(){console.log("[Store] Initializing..."),this.loading=!0,this.closeModal(),this.closeInputModal();try{await this.loadData(),console.log("[Store] Data loaded")}catch(e){console.error("[Store] Failed to load data",e)}finally{this.loading=!1}},loadData:async()=>({lanes:(await Api.fetchSwimLanes()).map(e=>({...e,collapsed:!0,loading:!0}))}),getLaneStats(e){const t=(this.tasks||[]).filter(t=>t.swimLane&&t.swimLane.id===e),o=t.length,s=t.filter(e=>"TODO"===e.status).length,a=t.filter(e=>"IN_PROGRESS"===e.status).length,i=t.filter(e=>"DONE"===e.status).length,l=t.filter(e=>"BLOCKED"===e.status).length,n=t.filter(e=>"DEFERRED"===e.status).length,r=e=>o>0?Math.round(e/o*100):0;return console.log(`[Store] getLaneStats(${e}):`,{total:o,todo:s,inProgress:a,done:i,blocked:l,deferred:n}),{total:o,todo:s,inProgress:a,done:i,blocked:l,deferred:n,todoPct:r(s),inProgressPct:r(a),donePct:r(i),blockedPct:r(l),deferredPct:r(n),completionPct:r(i)}},async fetchLaneTasks(e){console.log("[Store] fetchLaneTasks - Calling API with:",{laneId:e});try{const t=await Api.fetchTasksByLane(e);return console.log(`[Store] fetchLaneTasks - Received ${t.length} tasks for lane ${e}`),this.tasks=this.tasks.filter(t=>!t.swimLane||t.swimLane.id!==e),this.tasks.push(...t),t}catch(t){throw console.error(`[Store] fetchLaneTasks - FAILED for lane ${e}:`,t),t}},toggleLaneCollapse(e){console.log("[Store] toggleLaneCollapse called with laneId:",e);const t=this.lanes.find(t=>t.id===e);if(t){const e=t.collapsed;t.collapsed=!t.collapsed,console.log("[Store] toggleLaneCollapse - Lane:",t.name,"collapsed:",e,"->",t.collapsed)}else console.warn("[Store] toggleLaneCollapse - Lane not found:",e)},toggleAllLanes(){const e=!!this.lanes.some(e=>!e.collapsed);this.lanes.forEach(t=>t.collapsed=e)},areAllLanesCollapsed(){return this.lanes.length>0&&this.lanes.every(e=>e.collapsed)},confirmAction(e,t){console.log(`[Store] Opening Confirm Modal for ${e}`,t),this.modal.payload=t,this.modal.action=e,this.modal.open=!0,document.body.style.overflow="hidden","deleteLane"===e?(this.modal.title="Delete Swimlane?",this.modal.message="This will archive the swimlane. You can restore it later from database/admin.",this.modal.type="danger",this.modal.confirmText="Delete"):"completeLane"===e?(this.modal.title="Complete Swimlane?",this.modal.message="This will mark all tasks as done and hide the lane.",this.modal.type="success",this.modal.confirmText="Complete"):"deleteComment"===e&&(this.modal.title="Delete Comment?",this.modal.message="Are you sure you want to delete this comment?",this.modal.type="danger",this.modal.confirmText="Delete")},closeModal(){console.log("[Store] Closing Confirm Modal"),this.modal.open=!1,document.body.style.overflow="",setTimeout(()=>{this.modal.action=null,this.modal.payload=null},300)},confirmModalAction(){console.log("[Store] Generic Confirm Action Triggered");const{action:e,payload:t}=this.modal;"deleteLane"===e&&this.deleteLaneRecursive(t),"completeLane"===e&&this.completeLaneRecursive(t),"deleteComment"===e&&this.executeDeleteComment(t),this.closeModal()},openSwimlaneModal(){console.log("[Store] Opening Swimlane Input Modal"),this.inputModal.mode="SWIMLANE",this.inputModal.title="New Board (Swimlane)",this.inputModal.value="",this.inputModal.open=!0,document.body.style.overflow="hidden",setTimeout(()=>{const e=document.querySelector('[x-ref="inputField"]');e&&e.focus()},100)},openTaskModal(e){console.log(`[Store] Opening Task Input Modal for Lane ${e}`);const t=this.lanes.find(t=>t.id===e),o=t?t.name:"Unknown";this.inputModal.mode="TASK",this.inputModal.title="New Task",this.inputModal.laneName=o,this.inputModal.value="",this.inputModal.status="TODO",this.inputModal.tags=[],this.inputModal.tagInput="",this.inputModal.payload={laneId:e},this.inputModal.open=!0,document.body.style.overflow="hidden",setTimeout(()=>{const e=document.querySelector('[x-ref="inputField"]');e&&e.focus()},100)},closeInputModal(){console.log("[Store] Closing Input Modal"),this.inputModal.open=!1,document.body.style.overflow="",setTimeout(()=>{this.inputModal.value="",this.inputModal.status="TODO",this.inputModal.tags=[],this.inputModal.tagInput=""},300)},addTag(){const e=this.inputModal.tagInput.trim();e&&!this.inputModal.tags.includes(e)&&(this.inputModal.tags.push(e),console.log("[Store] Added tag:",e,"All tags:",this.inputModal.tags)),this.inputModal.tagInput=""},removeTag(e){const t=this.inputModal.tags.splice(e,1);console.log("[Store] Removed tag:",t,"Remaining tags:",this.inputModal.tags)},async submitInputModal(){console.log("[Store] Submitting Input Modal",this.inputModal);const e=this.inputModal.value.trim();if(e){if("SWIMLANE"===this.inputModal.mode)await this.createSwimLane(e);else if("TASK"===this.inputModal.mode){const t=this.inputModal.payload.laneId,o=this.inputModal.status||"TODO",s=this.inputModal.tags||[];await this.createTask(e,t,o,s)}this.closeInputModal()}else console.warn("[Store] Input empty, ignoring")},async createSwimLane(e){console.log("[Store] createSwimLane - Calling API with:",{name:e});try{const t=await Api.createSwimLane(e);console.log("[Store] createSwimLane - Created successfully:",t),t.collapsed=!1,t.loading=!1,this.lanes.push(t),this.triggerSave()}catch(e){console.error("[Store] createSwimLane - FAILED:",e),this.showError("Error creating lane")}},async createTask(e,t,o="TODO",s=[]){console.log("[Store] createTask - Calling API with:",{name:e,laneId:t,status:o,tags:s});try{if(!this.lanes.find(e=>e.id===t))return void console.error("[Store] createTask - Lane not found:",t);const a={name:e,status:o,tags:s.length>0?JSON.stringify(s):null,swimLane:{id:t}};console.log("[Store] createTask - Full payload:",a);const i=await Api.createTask(a);console.log("[Store] createTask - Created successfully:",i),this.tasks.push(i),this.triggerSave()}catch(e){console.error("[Store] createTask - FAILED:",e),this.showError("Error creating task")}},async moveTaskOptimistic(e,t,o,s){const a=performance.now();console.log("[Store] moveTaskOptimistic - Params:",{taskId:e,newStatus:t,newLaneId:o,newIndex:s});const i=this.tasks.find(t=>t.id==e);if(!i)return void console.error("[Store] moveTaskOptimistic - Task not found:",e);const l=i.status,n=i.swimLane?.id,r=i.position;if(console.log("[Store] moveTaskOptimistic - Original state:",{originalStatus:l,originalLaneId:n,originalPosition:r}),i.status=t,o){const e=this.lanes.find(e=>e.id==o);e&&(i.swimLane=e)}null!=s&&(i.position=s),console.log(`[TIMING] Optimistic UI update completed in ${(performance.now()-a).toFixed(1)}ms`);try{const i=performance.now();console.log("[Store] moveTaskOptimistic - Calling API.moveTask with:",{taskId:e,newStatus:t,newLaneId:o,newIndex:s}),await Api.moveTask(e,t,o,s),console.log(`[TIMING] API moveTask() call completed in ${(performance.now()-i).toFixed(1)}ms`),console.log(`[TIMING] Total moveTaskOptimistic() completed in ${(performance.now()-a).toFixed(1)}ms`),this.triggerSave()}catch(e){console.error("[Store] moveTaskOptimistic - FAILED, rolling back:",e),i.status=l;const t=this.lanes.find(e=>e.id==n);t&&(i.swimLane=t),i.position=r,t&&(i.swimLane=t),i.position=r,this.showError("Failed to move task")}},async reorderLanesOptimistic(e){console.log("[Store] reorderLanesOptimistic - Calling API with:",{newIds:e});try{await Api.reorderSwimlanes(e),console.log("[Store] reorderLanesOptimistic - Reorder successful"),this.triggerSave()}catch(e){console.error("[Store] reorderLanesOptimistic - FAILED:",e),this.loadData(),this.showError("Failed to reorder lanes")}},async deleteLaneRecursive(e){console.log("[Store] deleteLaneRecursive - Calling API with:",{laneId:e});const t=[...this.lanes];this.lanes=this.lanes.filter(t=>t.id!==e);try{await Api.deleteSwimLane(e),console.log("[Store] deleteLaneRecursive - Deleted successfully"),this.triggerSave()}catch(e){console.error("[Store] deleteLaneRecursive - FAILED:",e),this.lanes=t,this.showError("Failed to delete lane")}},async completeLaneRecursive(e){console.log("[Store] completeLaneRecursive - Calling API with:",{laneId:e});const t=this.lanes.find(t=>t.id===e);t&&(t.isCompleted=!0),this.lanes=this.lanes.filter(t=>t.id!==e);try{await Api.completeSwimLane(e),console.log("[Store] completeLaneRecursive - Completed successfully"),this.triggerSave()}catch(e){console.error("[Store] completeLaneRecursive - FAILED:",e),t&&(t.isCompleted=!1,this.lanes.push(t),this.loadData())}},triggerSave(){console.log("[Store] triggerSave - Showing saved toast"),this.showSaved=!0,this.saveTimeout&&clearTimeout(this.saveTimeout),this.saveTimeout=setTimeout(()=>this.showSaved=!1,1500)},triggerError(e){this.errorMessage=e,this.showErrorToast=!0,this.errorTimeout&&clearTimeout(this.errorTimeout),this.errorTimeout=setTimeout(()=>this.showErrorToast=!1,3e3)},showError(e){this.triggerError(e)},onServerTaskUpdate(e){const t=performance.now(),o=this.tasks.findIndex(t=>t.id==e.id);if(-1!==o){const s=this.tasks[o],a={...s,...e,swimLane:e.swimLane||s.swimLane};this.tasks[o]=a,this.taskDetail&&this.taskDetail.open&&this.taskDetail.task&&this.taskDetail.task.id==e.id&&(console.log("[App] SSE Sync: Updating task detail pane data"),this.taskDetail.task=a),console.log(`[TIMING] SSE task-update (merged) processed in ${(performance.now()-t).toFixed(1)}ms`)}else this.tasks.push(e),console.log(`[TIMING] SSE task-update (new) processed in ${(performance.now()-t).toFixed(1)}ms`);this.triggerSave()},onServerTaskDelete(e){const t=performance.now();this.tasks=this.tasks.filter(t=>t.id!=e),console.log(`[TIMING] SSE task-delete processed in ${(performance.now()-t).toFixed(1)}ms`)}};