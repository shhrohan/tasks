import{Api}from"./api.js";export const Store={lanes:[],tasks:[],loading:!1,viewMode:"ACTIVE",isCreatingTask:!1,isCreatingLane:!1,isDeletingLane:!1,isCompletingLane:!1,isReorderingLanes:!1,isAddingComment:!1,isUpdatingComment:!1,isDeletingComment:!1,isSubmittingModal:!1,showSaved:!1,showErrorToast:!1,errorMessage:"",saveTimeout:null,errorTimeout:null,modal:{open:!1,title:"",message:"",type:"info",confirmText:"Confirm",action:null,payload:null},inputModal:{open:!1,title:"",value:"",status:"TODO",tags:[],tagInput:"",laneName:"",mode:"",payload:null},userModal:{open:!1,name:"",email:"",joinedAt:"",isEditing:!1},columns:["TODO","IN_PROGRESS","DONE","BLOCKED","DEFERRED"],async init(){console.log("[Store] Initializing..."),this.loading=!0,this.closeModal(),this.closeInputModal();try{await this.loadData(),console.log("[Store] Data loaded")}catch(e){console.error("[Store] Failed to load data",e)}finally{this.loading=!1}},async loadData(){let e;console.log("[Store] loadData() - Fetching lanes for mode:",this.viewMode),e="COMPLETED"===this.viewMode?await Api.fetchCompletedSwimLanes():await Api.fetchSwimLanes();return{lanes:e.map(e=>({...e,collapsed:!0,loading:!0}))}},async setViewMode(e){if(this.viewMode!==e){console.log("[Store] Switching viewMode to:",e),this.viewMode=e,this.loading=!0;try{if("function"==typeof this.loadViaApi)await this.loadViaApi();else{const e=await this.loadData();this.lanes=e.lanes,this.tasks=[]}console.log("[Store] View changed, data reloaded from server")}catch(t){console.error("[Store] Failed to load "+e+" lanes",t),this.showError("Failed to load "+e.toLowerCase()+" boards")}finally{this.loading=!1}this.$nextTick&&this.$nextTick(()=>{this.lanes.forEach(e=>{this.isLaneVisible(e.id)&&this.reinitSortableForLane(e.id)})})}},getLaneStats(e){const t=(this.tasks||[]).filter(t=>t.swimLane&&t.swimLane.id===e),o=t.length,s=t.filter(e=>"TODO"===e.status).length,i=t.filter(e=>"IN_PROGRESS"===e.status).length,a=t.filter(e=>"DONE"===e.status).length,n=t.filter(e=>"BLOCKED"===e.status).length,l=t.filter(e=>"DEFERRED"===e.status).length,r=e=>o>0?Math.round(e/o*100):0;return{total:o,todo:s,inProgress:i,done:a,blocked:n,deferred:l,todoPct:r(s),inProgressPct:r(i),donePct:r(a),blockedPct:r(n),deferredPct:r(l),completionPct:r(a)}},async fetchLaneTasks(e){console.log("[Store] fetchLaneTasks - Calling API with:",{laneId:e});try{const t=await Api.fetchTasksByLane(e);return console.log(`[Store] fetchLaneTasks - Received ${t.length} tasks for lane ${e}`),this.tasks=this.tasks.filter(t=>!t.swimLane||t.swimLane.id!==e),this.tasks.push(...t),t}catch(t){throw console.error(`[Store] fetchLaneTasks - FAILED for lane ${e}:`,t),t}},toggleLaneCollapse(e){const t=this.lanes.find(t=>t.id===e);t&&(t.collapsed=!t.collapsed)},toggleAllLanes(){const e=!!this.lanes.some(e=>!e.collapsed);this.lanes.forEach(t=>t.collapsed=e)},areAllLanesCollapsed(){return this.lanes.length>0&&this.lanes.every(e=>e.collapsed)},confirmAction(e,t){console.log(`[Store] Opening Confirm Modal for ${e}`,t),this.modal.payload=t,this.modal.action=e,this.modal.open=!0,document.body.style.overflow="hidden","deleteLane"===e?(this.modal.title="Delete Swimlane?",this.modal.message="This will archive the swimlane. You can restore it later from database/admin.",this.modal.type="danger",this.modal.confirmText="Delete"):"completeLane"===e?(this.modal.title="Mark Swimlane Complete?",this.modal.message="This will mark all tasks as DONE and move the board to Completed view.",this.modal.type="success",this.modal.confirmText="Mark Complete"):"uncompleteLane"===e?(this.modal.title="Reactivate Swimlane?",this.modal.message="This will move the board back to Active view.",this.modal.type="primary",this.modal.confirmText="Reactivate"):"deleteComment"===e&&(this.modal.title="Delete Comment?",this.modal.message="Are you sure you want to delete this comment?",this.modal.type="danger",this.modal.confirmText="Delete")},closeModal(){console.log("[Store] Closing Confirm Modal"),this.modal.open=!1,document.body.style.overflow="",setTimeout(()=>{this.modal.action=null,this.modal.payload=null},300)},confirmModalAction(){console.log("[Store] Generic Confirm Action Triggered");const{action:e,payload:t}=this.modal;"deleteLane"===e&&this.deleteLaneRecursive(t),"completeLane"===e&&this.completeLaneRecursive(t),"uncompleteLane"===e&&this.uncompleteLaneRecursive(t),"deleteComment"===e&&this.executeDeleteComment(t)},openSwimlaneModal(){console.log("[Store] Opening Swimlane Input Modal"),this.inputModal.mode="SWIMLANE",this.inputModal.title="New Board (Swimlane)",this.inputModal.value="",this.inputModal.open=!0,document.body.style.overflow="hidden",setTimeout(()=>{const e=document.querySelector('[x-ref="inputField"]');e&&e.focus()},100)},openTaskModal(e){console.log(`[Store] Opening Task Input Modal for Lane ${e}`);const t=this.lanes.find(t=>t.id===e),o=t?t.name:"Unknown";this.inputModal.mode="TASK",this.inputModal.title="New Task",this.inputModal.laneName=o,this.inputModal.value="",this.inputModal.status="TODO",this.inputModal.tags=[],this.inputModal.tagInput="",this.inputModal.payload={laneId:e},this.inputModal.open=!0,document.body.style.overflow="hidden",setTimeout(()=>{const e=document.querySelector('[x-ref="inputField"]');e&&e.focus()},100)},closeInputModal(){console.log("[Store] Closing Input Modal"),this.inputModal.open=!1,document.body.style.overflow="",setTimeout(()=>{this.inputModal.value="",this.inputModal.status="TODO",this.inputModal.tags=[],this.inputModal.tagInput=""},300)},openUserModal(){console.log("[Store] Opening User Profile Modal");const e=window.initialData.user;this.userModal.name=e.name,this.userModal.email=e.email,this.userModal.joinedAt=e.joinedAt||"N/A",this.userModal.isEditing=!1,this.userModal.open=!0,document.body.style.overflow="hidden"},closeUserModal(){console.log("[Store] Closing User Profile Modal"),this.userModal.open=!1,this.userModal.isEditing=!1,document.body.style.overflow=""},async updatePersona(){if(this.userModal.name.trim()){console.log("[Store] updatePersona - Calling API with name:",this.userModal.name);try{const e=await Api.updateUser(this.userModal.name);console.log("[Store] updatePersona - Updated successfully:",e),window.initialData.user.name=e.name,window.initialData.user.firstName=e.name.split(" ")[0],this.userModal.isEditing=!1,this.triggerSave()}catch(e){console.error("[Store] updatePersona - FAILED:",e),this.showError("Error updating profile")}}},addTag(){const e=this.inputModal.tagInput.trim();e&&!this.inputModal.tags.includes(e)&&(this.inputModal.tags.push(e),console.log("[Store] Added tag:",e,"All tags:",this.inputModal.tags)),this.inputModal.tagInput=""},removeTag(e){const t=this.inputModal.tags.splice(e,1);console.log("[Store] Removed tag:",t,"Remaining tags:",this.inputModal.tags)},async submitInputModal(){if(this.isSubmittingModal)console.warn("[Store] submitInputModal - Already submitting, ignoring");else{this.isSubmittingModal=!0,console.log("[Store] Submitting Input Modal",this.inputModal);try{const e=this.inputModal.value.trim();if(!e)return void console.warn("[Store] Input empty, ignoring");if("SWIMLANE"===this.inputModal.mode)await this.createSwimLane(e);else if("TASK"===this.inputModal.mode){const t=this.inputModal.payload.laneId,o=this.inputModal.status||"TODO",s=this.inputModal.tags||[];await this.createTask(e,t,o,s)}this.closeInputModal()}finally{this.isSubmittingModal=!1}}},async createSwimLane(e){if(this.isCreatingLane)console.warn("[Store] createSwimLane - Already creating, ignoring");else{this.isCreatingLane=!0,console.log("[Store] createSwimLane - Calling API with:",{name:e});try{const t=await Api.createSwimLane(e);console.log("[Store] createSwimLane - Created successfully:",t),t.collapsed=!1,t.loading=!1,this.lanes.push(t),this.triggerSave()}catch(e){console.error("[Store] createSwimLane - FAILED:",e),this.showError("Error creating lane")}finally{this.isCreatingLane=!1}}},async createTask(e,t,o="TODO",s=[]){if(this.isCreatingTask)console.warn("[Store] createTask - Already creating, ignoring");else{this.isCreatingTask=!0,console.log("[Store] createTask - Calling API with:",{name:e,laneId:t,status:o,tags:s});try{if(!this.lanes.find(e=>e.id===t))return void console.error("[Store] createTask - Lane not found:",t);const i={name:e,status:o,tags:s.length>0?JSON.stringify(s):null,swimLane:{id:t}};console.log("[Store] createTask - Full payload:",i);const a=await Api.createTask(i);console.log("[Store] createTask - Created successfully:",a),this.tasks.push(a),this.triggerSave()}catch(e){console.error("[Store] createTask - FAILED:",e),this.showError("Error creating task")}finally{this.isCreatingTask=!1}}},async updateTask(e,t){console.log("[Store] updateTask - Calling API with:",{taskId:e,taskPayload:t});try{const o=await Api.updateTask(e,t);console.log("[Store] updateTask - Updated successfully:",o);const s=this.tasks.findIndex(t=>t.id===e);return-1!==s&&(this.tasks[s]={...this.tasks[s],...o}),this.triggerSave(),o}catch(e){throw console.error("[Store] updateTask - FAILED:",e),this.showError("Error updating task"),e}},async moveTaskOptimistic(e,t,o,s){const i=performance.now();console.log("[Store] moveTaskOptimistic - Params:",{taskId:e,newStatus:t,newLaneId:o,newIndex:s});const a=this.tasks.find(t=>t.id==e);if(!a)return void console.error("[Store] moveTaskOptimistic - Task not found:",e);const n=a.status,l=a.swimLane?.id,r=a.position;if(console.log("[Store] moveTaskOptimistic - Original state:",{originalStatus:n,originalLaneId:l,originalPosition:r}),a.status=t,o){const e=this.lanes.find(e=>e.id==o);e&&(a.swimLane=e)}null!=s&&(a.position=s),console.log(`[TIMING] Optimistic UI update completed in ${(performance.now()-i).toFixed(1)}ms`);try{const a=performance.now();console.log("[Store] moveTaskOptimistic - Calling API.moveTask with:",{taskId:e,newStatus:t,newLaneId:o,newIndex:s}),await Api.moveTask(e,t,o,s),console.log(`[TIMING] API moveTask() call completed in ${(performance.now()-a).toFixed(1)}ms`),console.log(`[TIMING] Total moveTaskOptimistic() completed in ${(performance.now()-i).toFixed(1)}ms`),this.triggerSave()}catch(e){console.error("[Store] moveTaskOptimistic - FAILED, rolling back:",e),a.status=n;const t=this.lanes.find(e=>e.id==l);t&&(a.swimLane=t),a.position=r,t&&(a.swimLane=t),a.position=r,this.showError("Failed to move task")}},async reorderLanesOptimistic(e){if(this.isReorderingLanes)console.warn("[Store] reorderLanesOptimistic - Already reordering, ignoring");else{this.isReorderingLanes=!0,console.log("[Store] reorderLanesOptimistic - Calling API with:",{newIds:e});try{await Api.reorderSwimlanes(e),console.log("[Store] reorderLanesOptimistic - Reorder successful"),this.triggerSave()}catch(e){console.error("[Store] reorderLanesOptimistic - FAILED:",e),this.loadData(),this.showError("Failed to reorder lanes")}finally{this.isReorderingLanes=!1}}},async deleteLaneRecursive(e){if(this.isDeletingLane)return void console.warn("[Store] deleteLaneRecursive - Already deleting, ignoring");this.isDeletingLane=!0,console.log("[Store] deleteLaneRecursive - Calling API with:",{laneId:e});const t=[...this.lanes];this.lanes=this.lanes.filter(t=>t.id!==e);try{await Api.deleteSwimLane(e),console.log("[Store] deleteLaneRecursive - Deleted successfully"),this.triggerSave()}catch(e){console.error("[Store] deleteLaneRecursive - FAILED:",e),this.lanes=t,this.showError("Failed to delete lane")}finally{this.isDeletingLane=!1,this.closeModal()}},async completeLaneRecursive(e){if(this.isCompletingLane)return void console.warn("[Store] completeLaneRecursive - Already completing, ignoring");this.isCompletingLane=!0,console.log("[Store] completeLaneRecursive - Calling API with:",{laneId:e});const t=this.lanes.find(t=>t.id===e);t&&(t.isCompleted=!0);try{await Api.completeSwimLane(e),console.log("[Store] completeLaneRecursive - Completed successfully"),this.triggerSave()}catch(e){console.error("[Store] completeLaneRecursive - FAILED:",e),t&&(t.isCompleted=!1,this.lanes.push(t),this.loadData())}finally{this.isCompletingLane=!1,this.closeModal()}},async uncompleteLaneRecursive(e){if(this.loading)return;console.log("[Store] uncompleteLaneRecursive - Calling API with:",{laneId:e});const t=this.lanes.find(t=>t.id===e);t&&(t.isCompleted=!1);try{await Api.uncompleteSwimLane(e),console.log("[Store] uncompleteLaneRecursive - Reactivated successfully"),this.triggerSave()}catch(e){console.error("[Store] uncompleteLaneRecursive - FAILED:",e),t&&(t.isCompleted=!0,this.lanes.push(t)),this.showError("Failed to reactivate lane")}finally{this.closeModal()}},triggerSave(){console.log("[Store] triggerSave - Showing saved toast"),this.showSaved=!0,this.saveTimeout&&clearTimeout(this.saveTimeout),this.saveTimeout=setTimeout(()=>this.showSaved=!1,1500)},triggerError(e){this.errorMessage=e,this.showErrorToast=!0,this.errorTimeout&&clearTimeout(this.errorTimeout),this.errorTimeout=setTimeout(()=>this.showErrorToast=!1,3e3)},showError(e){this.triggerError(e)},onServerTaskUpdate(e){const t=performance.now(),o=this.tasks.findIndex(t=>t.id==e.id);if(-1!==o){const s=this.tasks[o],i={...s,...e,swimLane:e.swimLane||s.swimLane};this.tasks[o]=i,this.taskDetail&&this.taskDetail.open&&this.taskDetail.task&&this.taskDetail.task.id==e.id&&(console.log("[App] SSE Sync: Updating task detail pane data"),this.taskDetail.task=i),console.log(`[TIMING] SSE task-update (merged) processed in ${(performance.now()-t).toFixed(1)}ms`)}else this.tasks.push(e),console.log(`[TIMING] SSE task-update (new) processed in ${(performance.now()-t).toFixed(1)}ms`);this.triggerSave()},onServerTaskDelete(e){const t=performance.now();this.tasks=this.tasks.filter(t=>t.id!=e),console.log(`[TIMING] SSE task-delete processed in ${(performance.now()-t).toFixed(1)}ms`)}};