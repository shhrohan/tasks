export const Drag={initOneColumn(t,e,a){if(t.sortableInstance)return void console.log(`[Drag] SKIP Init: Lane ${t.getAttribute("data-lane-id")} Status ${t.getAttribute("data-status")} (Already has instance)`);const o=t.getAttribute("data-lane-id"),n=t.getAttribute("data-status"),r=t.querySelectorAll(".task-card");if(console.log("[Drag] ====== Initializing Column ======"),console.log(`[Drag] Lane: ${o}, Status: ${n}`),console.log(`[Drag] Column ID: ${t.id}`),console.log(`[Drag] Task cards found: ${r.length}`),0===r.length&&console.warn("[Drag] WARNING: Column has 0 task-cards! Sortable drag may not work until reinitSortableForLane() is called after tasks load."),"undefined"==typeof Sortable)return console.error("[Drag] FATAL ERROR: Sortable library is not loaded!"),void console.error('[Drag] Ensure <script src="Sortable.min.js"><\/script> is included before app.js');try{t.sortableInstance=new Sortable(t,{group:`tasks-lane-${o}`,animation:150,delay:0,delayOnTouchOnly:!0,touchStartThreshold:3,ghostClass:"task-ghost",dragClass:"task-drag",removeCloneOnHide:!0,forceFallback:!0,onChoose(t){const e=t.item;if(!e)return;console.log("[Drag] onChoose - item:",e.getAttribute("data-task-id"),"tagName:",e.tagName),e.setAttribute("x-ignore","");const a=e.matches(".task-card")?e:e.querySelector(".task-card");a&&a!==e&&(a.setAttribute("x-ignore",""),console.log("[Drag] onChoose - Added x-ignore to inner .task-card",a.getAttribute("data-task-id"))),console.log("[Drag] onChoose - x-ignore applied",e.getAttribute("data-task-id"))},onUnchoose(t){const e=t.item;if(!e)return;e.removeAttribute("x-ignore");const a=e.matches(".task-card")?e:e.querySelector(".task-card");a&&a!==e&&a.removeAttribute("x-ignore"),console.log("[Drag] onUnchoose - Removed x-ignore from item",e.getAttribute("data-task-id"))},onStart:t=>{const e=t.from.getAttribute("data-lane-id");console.log("[Drag] onStart - Drag began:",{taskId:t.item.getAttribute("data-task-id"),fromColumn:t.from.getAttribute("data-status"),fromLane:e}),document.querySelectorAll(".swimlane-row").forEach(t=>{const a=t.querySelector(".lane-column")?.getAttribute("data-lane-id");a===e?t.classList.add("drag-active-lane"):t.classList.add("drag-disabled-lane")})},onMove:t=>{const e=t.from?.getAttribute("data-lane-id"),a=t.to?.getAttribute("data-lane-id");return e!==a?(console.log("[Drag] onMove - BLOCKED: Cannot move between swimlanes",{fromLane:e,toLane:a}),!1):(console.log("[Drag] onMove - Allowed:",{targetColumn:t.to?.getAttribute("data-status"),targetLane:a}),!0)},onEnd:t=>{document.querySelectorAll(".swimlane-row").forEach(t=>{t.classList.remove("drag-active-lane","drag-disabled-lane")});const a=t.item,o=t.to,n=t.from,r=t.newIndex,l=t.oldIndex;if(console.log("[Drag] onEnd - Drag completed:",{taskId:a.getAttribute("data-task-id"),fromColumn:n.getAttribute("data-status"),toColumn:o.getAttribute("data-status"),fromLane:n.getAttribute("data-lane-id"),toLane:o.getAttribute("data-lane-id"),oldIndex:l,newIndex:r,sameContainer:o===n}),o===n&&r===l)return void console.log("[Drag] No position change, skipping API call");const s=a.getAttribute("data-task-id"),i=o.getAttribute("data-status"),d=o.getAttribute("data-lane-id");console.log(`[Drag] Moving task ${s} to ${i} in lane ${d} at index ${r}`),e.moveTaskOptimistic(s,i,d,r)}}),console.log("[Drag] Sortable instance created successfully"),console.log("[Drag] ====================================")}catch(t){console.error("[Drag] ERROR creating Sortable instance:",t),console.error("[Drag] Stack trace:",t.stack)}},initLaneSortable(t,e,a){t?(console.log("[Drag] Initializing Lane Sortable on .board-container"),t.sortableInstance&&(console.log("[Drag] Destroying existing lane Sortable instance"),t.sortableInstance.destroy()),t.sortableInstance=new Sortable(t,{handle:".swimlane-header",animation:150,ghostClass:"lane-ghost",onStart:t=>{console.log("[Drag] Lane drag started:",{laneId:t.item.getAttribute("data-lane-id")})},onEnd:o=>{if(o.newIndex===o.oldIndex)return void console.log("[Drag] Lane position unchanged, skipping");console.log("[Drag] Lane reorder detected:",{oldIndex:o.oldIndex,newIndex:o.newIndex});const n=Array.from(t.children).map(t=>t.getAttribute("data-lane-id")).filter(t=>t);console.log("[Drag] New lane order:",n),e.reorderLanesOptimistic(n),a&&a()}}),console.log("[Drag] Lane Sortable initialized successfully")):console.error("[Drag] ERROR: No container element provided for lane sorting")}};