export const Drag={initOneColumn(t,e){if(t.sortableInstance)return void console.log(`[Drag] SKIP Init: Lane ${t.getAttribute("data-lane-id")} Status ${t.getAttribute("data-status")} (Already has instance)`);const a=t.getAttribute("data-lane-id"),o=t.getAttribute("data-status"),n=t.querySelectorAll(".task-card");if(console.log("[Drag] ====== Initializing Column ======"),console.log(`[Drag] Lane: ${a}, Status: ${o}`),console.log(`[Drag] Column ID: ${t.id}`),console.log(`[Drag] Task cards found: ${n.length}`),0===n.length&&console.warn("[Drag] WARNING: Column has 0 task-cards! Sortable drag may not work until reinitSortableForLane() is called after tasks load."),"undefined"==typeof Sortable)return console.error("[Drag] FATAL ERROR: Sortable library is not loaded!"),void console.error('[Drag] Ensure <script src="Sortable.min.js"><\/script> is included before app.js');try{t.sortableInstance=new Sortable(t,{group:"tasks",animation:150,delay:0,delayOnTouchOnly:!0,touchStartThreshold:3,ghostClass:"task-ghost",dragClass:"task-drag",removeCloneOnHide:!0,forceFallback:!1,onChoose:t=>{console.log("[Drag] onChoose - User selected item:",{taskId:t.item.getAttribute("data-task-id"),element:t.item})},onStart:t=>{console.log("[Drag] onStart - Drag began:",{taskId:t.item.getAttribute("data-task-id"),fromColumn:t.from.getAttribute("data-status"),fromLane:t.from.getAttribute("data-lane-id")})},onClone:t=>{const e=t.clone;if(e){const t=e.querySelector(".card-title")?.textContent||"Task",a=e.getAttribute("data-task-id");e.setAttribute("x-ignore",""),e.innerHTML=`\n                            <div class="card-body p-2">\n                                <p class="h6 card-title text-white mb-1">${t}</p>\n                            </div>\n                        `,console.log("[Drag] onClone - Created static ghost for task:",a)}},onMove:t=>(console.log("[Drag] onMove - Dragging over:",{targetColumn:t.to?.getAttribute("data-status"),targetLane:t.to?.getAttribute("data-lane-id")}),!0),onEnd:t=>{const a=t.item,o=t.to,n=t.from,r=t.newIndex,l=t.oldIndex;if(console.log("[Drag] onEnd - Drag completed:",{taskId:a.getAttribute("data-task-id"),fromColumn:n.getAttribute("data-status"),toColumn:o.getAttribute("data-status"),fromLane:n.getAttribute("data-lane-id"),toLane:o.getAttribute("data-lane-id"),oldIndex:l,newIndex:r,sameContainer:o===n}),o===n&&r===l)return void console.log("[Drag] No position change, skipping API call");const s=a.getAttribute("data-task-id"),i=o.getAttribute("data-status"),d=o.getAttribute("data-lane-id");console.log(`[Drag] Moving task ${s} to ${i} in lane ${d} at index ${r}`),e.moveTaskOptimistic(s,i,d,r)}}),console.log("[Drag] Sortable instance created successfully"),console.log("[Drag] ====================================")}catch(t){console.error("[Drag] ERROR creating Sortable instance:",t),console.error("[Drag] Stack trace:",t.stack)}},initLaneSortable(t,e,a){t?(console.log("[Drag] Initializing Lane Sortable on .board-container"),t.sortableInstance&&(console.log("[Drag] Destroying existing lane Sortable instance"),t.sortableInstance.destroy()),t.sortableInstance=new Sortable(t,{handle:".swimlane-header",animation:150,ghostClass:"lane-ghost",onStart:t=>{console.log("[Drag] Lane drag started:",{laneId:t.item.getAttribute("data-lane-id")})},onEnd:o=>{if(o.newIndex===o.oldIndex)return void console.log("[Drag] Lane position unchanged, skipping");console.log("[Drag] Lane reorder detected:",{oldIndex:o.oldIndex,newIndex:o.newIndex});const n=Array.from(t.children).map(t=>t.getAttribute("data-lane-id")).filter(t=>t);console.log("[Drag] New lane order:",n),e.reorderLanesOptimistic(n),a&&a()}}),console.log("[Drag] Lane Sortable initialized successfully")):console.error("[Drag] ERROR: No container element provided for lane sorting")}};